\documentclass[twocolumn, aps, amsmath, amssymb, nofootinbib, superscriptaddress, longbibliography, doublefloatfix, table-of-contents, eqsecnum, rmp]{revtex4-2}

\usepackage[pdftex]{graphicx}
\usepackage{mathrsfs}
\usepackage[colorlinks, breaklinks, urlcolor={blue}, linkcolor={red}, citecolor={blue}]{hyperref}
\usepackage[english]{babel}
\usepackage{booktabs}
\usepackage{type1cm}
\usepackage{caption}
\usepackage{url}
\usepackage[breaklinks]{hyperref}
\usepackage{stmaryrd}
    
\frenchspacing
    
\captionsetup[figure]{margin=0pt, font=small, labelfont=bf, labelsep=endash, justification=centerlast, labelsep=colon}
\captionsetup[algorithm]{margin=0pt, font=small, labelfont=bf, labelsep=endash, justification=centerlast, labelsep=colon}
    
\def\sk{\mathtt{sk}}
\def\pk{\mathtt{pk}}
\def\kp{\mathtt{kp}}
\def\sig{\mathtt{sig}}
\def\ver{\mathtt{ver}}
\def\enc{\mathtt{enc}}
\def\dec{\mathtt{dec}}
\def\zerovec{\mathbf{0}}
\def\diff#1#2{\llbracket #1,#2\rrbracket}
\def\asym#1#2#3{\langle #1_#3 #2_{#3^{-1}}\rangle}
\def\asymd#1#2#3#4{\langle #1_{#3} \cdot #2_{#4}\rangle}
\def\braid#1#2#3#4{\langle#1,#2\rangle_{#3}^{#4}}
\def\selfbraid#1#2#3{\langle#1\rangle_{#2}^{#3}}
\def\comm#1#2#3#4{[#1,#2]_{#3}^{#4}}
% \def\soplus{{\mathbin{\scriptstyle{\mathbin\oplus}}}}

\makeatletter
\newcommand{\soplus}{{{\hspace{1pt}}{\mathbin{\mathpalette\make@small\oplus}}}{\hspace{1pt}}}

\newcommand{\make@small}[2]{%
  \vcenter{\hbox{%
    \scalebox{0.6}{$\m@th#1#2$}%
  }}%
}
\makeatother

\begin{document}

\title{Information theoretically secure post-quantum cryptography}

\author{Peter P. Rohde}
\email[]{peter@peterrohde.org}
\homepage{https://www.peterrohde.org}

\begin{abstract}
\end{abstract}

\maketitle

\tableofcontents

\section{Links \& chats}

\begin{itemize}
	\item One way functions and P vs NP: \url{https://en.wikipedia.org/wiki/One-way_function}: "The existence of such one-way functions is still an open conjecture. Their existence would prove that the complexity classes P and NP are not equal,"
	\item GapP, NP, binary optimisation problems: \url{https://chatgpt.com/share/2e9f8c0f-fa1d-4d97-9af0-c195ad3cd22c}
	\item Homomorphism between $B_n$ and $S_n$: \url{https://chatgpt.com/share/c0390897-77f1-403e-bce9-ca2bf5c9fccc}
	\item Even Hamming weight for $H(x\soplus y)\in 2\mathbb{Z}$ if $H(x)=H(y)$. Hence also for $y=\pi\circ x$ where $\pi\in S_n$.
	\item Word problem for the braid group $B_n$ is poly-time solvable: \url{https://chatgpt.com/c/f8827503-7af9-4b81-b3dd-a79f1891746e}
	\item Wreath product \url{https://en.wikipedia.org/wiki/Wreath_product}
	\item Braid permutations \mbox{$\pi: B_n \to S_n$}, for $\beta\in B_n$ we have $\pi(\beta)$: \url{https://chatgpt.com/share/6c61f5ef-a33d-4c76-8f1f-0d8bdf1bb4aa}
\end{itemize}

\section{Overview}

The goal is to create information-theoretically secure asymmetric PQC primitives where the only hardness assumption is the hardness of brute-force, reducing all arguments to entropic ones.

There are multiple primitives we will combine together.

The purpose of differential encoding is create differential pairs encoded against a secret, where the differential term is public and cannot reveal the secret itself.

Combining differential encoding with random codewords we have a codespace where all codewords are unique (statistical security assumption) and errors on differentials are always detectable (but not correctable).

Permutation codes and their respective algebra are used to create asymmetric primitives from random codewords. This closely relates to and is inspired by hash algebra. Here the central concept is that any permutation on the bits in codewords creates a distinct codeword (statistical security assumption). The asymmetric objects introduced here are defines under the algebra of the symmetric group and their inversion assuming random codewords is only via brute force as the objects are provably non-invertible.

The security of asymmetric objects relates to their pre-image space which decomposes into collisional and non-collisional partitions. The former is insecure (ambiguous secrets) while the latter is secure. Quantifying the size of these respective spaces affords provable statements on statistical security alone.

The schemes resulting from this are compositional under binary XOR algebra.

\section{Differential encoding}

A pair of bit-strings $\{x,y\}\in\{0,1\}^n$ may be expressed differentially using the tuple,
\begin{align}
	\diff{x}{y} &\equiv [x,x\soplus y] \nonumber\\
	&\equiv [x\soplus y,x].
\end{align}
Here the differential term $x\soplus y$ alone reveals no information about $x$ or $y$ while the non-differential term unlocks the code to reveal both. The validity of differentially encoded tuples may be trivially confirmed given knowledge of both terms.

Differential encodings are composable under $\soplus$,
\begin{align}
	\diff{x_1}{y_1} \soplus \diff{x_2}{y_2} \Rightarrow \diff{x_1\soplus x_2}{y_1 \soplus y_2},
\end{align}
with the properties,
\begin{align}
	\diff{\zerovec}{x\soplus y} &= \diff{x}{y}, \nonumber\\
	\diff{x}{y} &\Rightarrow x=y.
\end{align}

\section{Entropy codes}

Entropy codes employ random codewords,
\begin{align}
	\mathcal{X}: x \in \{0,1\}^n,
\end{align}
sampled using random variable $\mathcal{X}$ with respective per-bit Shannon entropy,
\begin{align}
	0\leq H(\mathcal{X})\leq 1.
\end{align}
Under maximum entropy $H(\mathcal{X})=1$ conditions all codewords are sampled with probability,
\begin{align}
	\mathbb{P}(x) = \frac{1}{2^n},	
\end{align}
and are orthogonal,
\begin{align}
	x_i \soplus x_j \neq \mathbf{0}.
\end{align}
Under differential encoding,
\begin{align}
	[x,x\soplus y],
\end{align}
entropy addition implies the differential term $x\soplus y$ exhibits entropy at least,
\begin{align}
	H(x\soplus y) \geq \min(H(x),H(y)).
\end{align}
Hence parity terms form unique random codewords.

For known $\{x,y\}$, its differential code $\diff{x}{y}$ affords both detection and correction of all bit-errors.

\subsection{Collision space}

The collision space of an $n$-bit function,
\begin{align}
	f_n(x) \to y,\quad x,y\in\{0,1\}^n,
\end{align}
is the number of images $y$ with multiple pre-images $x$,
\begin{align}
	\mathrm{Col}(f) = |\{\mathrm{Im}(x)\,|\,\mathrm{Im}(x)=\mathrm{Im}(y\neq x)\}|,
\end{align}
defining the non-invertible image subspace. In the collision-free subspace all images have single pre-images,
\begin{align}
	\overline{\mathrm{Col}}(f_n) + \mathrm{Col}(f_n) = 2^n,
\end{align}
paritioning the image space.

Random codes are vulnerable only when multiple secrets map to the same asymmetric encoding,
\begin{align}
	f:\, x,y \to \selfbraid{x}{\pi}{\pi^{-1}},\quad x\neq y.
\end{align}
Now the collision-free subspace of the public object is defined as secure while the collision space is insecure via pre-image ambiguity.

A birthday attack is a statistical attack on collision space where the goal is to find \emph{any} collision rather than a \emph{specific} collision, affording quadratically enhanced scaling. For an $n$-bit random bit-string with $2^n$ possible values, upon taking $k$ random samples the likelihood of finding a collision scales as,
\begin{align}
	\mathbb{P}(n,k) &\approx 1 - \exp\left[-\frac{k^2}{2^{n+1}}\right].
\end{align}
For $k=\mathrm{poly}(n)$ this ensures the asymptotic statistical security of random codewords $x$.

The collision space of asymmetric objects of the form $\selfbraid{x}{\pi}{\pi^{-1}}$ is given by the set of satisfying $y$ such that,
\begin{align}
	\selfbraid{x}{\pi}{\pi^{-1}} &= \selfbraid{y}{\pi}{\pi^{-1}},
\end{align}
the satisfiability problem of finding bit-strings which under a random braid have a given symmetric difference. This presumably mandates a brute-force search of pre-image space given that the group is the symmetric group with no hidden structure.

%\section{Algebraic cryptography}

\section{Permutation codes}

We define the algebra,
\begin{align}
	(\mathbb{Z}_2^n \times S_n, \soplus,\pi),
\end{align}
comprising the bitwise binary $(\mathbb{Z}_2^n,\soplus)$ operator and the unary $(S_n,\pi)$ operator. Defining permutations over bit-string elements,
\begin{align}
	\pi &\in S_n,\nonumber\\
	\pi\circ x &\equiv x_\pi,
\end{align}
as unary operators we inherit algebraic properties from the symmetric group.
\begin{itemize}
	\item \emph{Composition}: $[\pi_i \circ \pi_j]\circ x \equiv x_{\pi_i\circ \pi_j}$.
	\item \emph{Distributivity}: $\pi\circ(x\soplus y) \equiv [x\soplus y]_\pi \equiv x_\pi \soplus y_\pi$.
\end{itemize}
For unknown $x$, the permuted bit-string $x_\pi$ can be decoded to $x$ given $\pi$.

Structures of the form,
\begin{align}
	x_\pi x \equiv x_\pi \soplus x,
\end{align}
cannot be decoded from $\pi$ alone. However, the action of $x$ or $x_\pi$ on $x_\pi x$ reveals the other,
\begin{align}
	x \soplus (x_\pi \soplus x) & = x_\pi,\nonumber\\
	x_\pi \soplus (x_\pi \soplus x) &= x.
\end{align}
Via distributivity we have the additional symmetric property,
\begin{align}
	\pi^{-1} \circ (x_\pi x)	 = x_{\pi^{-1}} x.
\end{align}

Differential codes preserve their differential structure under common global permutations but not under non-uniform permutations,
\begin{align}
	\pi\circ \diff{x}{y}	 &\equiv \diff{x_\pi}{y_\pi},\nonumber\\
 	\diff{x_\pi}{y_\pi} &\sim \diff{x}{y},\nonumber\\
	\diff{x}{y_\pi} &\not\sim \diff{x}{y} \nonumber\\
	\diff{x_\pi}{y} &\not\sim \diff{x}{y}
\end{align}

\section{Asymmetric codes}

Consider objects $s_\pi s$ and $m_\pi \cdot h(m)$, both public, where Alice knows secret $s$ and Alice knows secret $m$.
\begin{align}
	[s_\pi s] \cdot [m_\pi h(m)] &= [s \cdot m] \cdot [s_\pi \cdot h(m_\pi)]
\end{align}


We use the notation,
\begin{align}
	x_{\pi_1} y_{\pi_2} \equiv \braid{x}{y}{\pi_1}{\pi_2},\nonumber\\
	x_{\pi} x_{\pi^{-1}} \equiv \selfbraid{x}{\pi}{\pi^{-1}}.
\end{align}
If a $\pi$ index is not written it's implied the identity permutation $\pi_0$.

This encoding under pairs of permutations implies a braid representation.

Sloppily we'll also use $x\soplus y \equiv x \cdot y \equiv xy$ as shorthand.

\subsection{One-way functions}

For secret $x$ we define the public object,
\begin{align} \label{eq:one_way_sum}
	x \xrightarrow{\pi} \selfbraid{x}{\pi}{\pi^{-1}}.
\end{align}
This defines a one-way function enabling verification given $x$ and $\pi$ but does not allow reverse evaluation of $x$ even if $\pi$ is known via pre-image resistance.

\subsection{Pre-image resistance}

Let,
\begin{align}
	\mathcal{X}: x\in\{0,1\}^n,\quad \mathrm{s.t.}\,\,w(x)=n/2,
\end{align}
be a random bit-string with Hamming weight \mbox{$w(x)=n/2$}. The automorphisms of $x$ are equivalent to all permutations over the subsets of elements with the same bit-value,
\begin{align}
	\mathrm{Aut}(x) &= \mathrm{Sym}(x^{(0)}) \times \mathrm{Sym}(x^{(1)}) \nonumber\\
	&= S_{n/2}\times S_{n/2}.
\end{align}
where,
\begin{align}
	x^{(k)}=\{i\,|\, x_i=k\}_{i\in x}.
\end{align}
The space of $x$ where $w(x)=n/2$ has order,
\begin{align}
	\frac{|\mathrm{Sym}(x)|}{|\mathrm{Aut}(x)|} = \frac{n!}{(\frac{n}{2})!(\frac{n}{2})!} = \binom{n}{n/2}.
\end{align}

All $x$ where $w(x)=n/2$ are related by permutations. Hence, for given $x$ and random $\pi\in S_n$, $x_\pi$ is an independent random bit-string with $w(x_\pi)=w(x)=n/2$.

Let,
\begin{align}
	x_\pi x = c,
\end{align}
be an asymmetric permutational primitive where $c$ is known and we want to find a satisfying pre-image $x$.

Consider the table,
\begin{align}
	[x_\pi,\tilde{x},\tilde{x}\soplus \tilde{c}]_i,
\end{align}
with rows over $i$, row-ordered such that the first block of $n/2$ rows have $x_i=0$ and the second block have $x_i=1$ (tilde denotes this ordering). The second and third columns are mutually order and under multiplication provide $\tilde{c}$. This is preserved under any permutation within blocks but not between blocks.

The pre-image solution corresponds to choosing $x_\pi$ such that multiplying the first column by the third column yields $\tilde{c}$.

\subsection{One-way functions}

The one-way function from Eq.~\eqref{eq:one_way_sum} acts distributively over $\soplus$,
\begin{align}
	x\soplus y \xrightarrow{\pi} \selfbraid{x}{\pi}{\pi^{-1}} \soplus \selfbraid{y}{\pi}{\pi^{-1}}.
\end{align}

%The one-way function from Eq.~\eqref{eq:one_way_sum} does not act distributively over $\soplus$,
%\begin{align}
%	(x\soplus y) &\xrightarrow{\pi} (x\soplus y)_\pi(x\soplus y)_{\pi^{-1}} \nonumber\\
%	&= x_\pi x_{\pi^{-1}} \soplus y_\pi y_{\pi^{-1}} \soplus x_\pi y_{\pi^{-1}} \soplus y_\pi x_{\pi^{-1}} \nonumber\\
%	&= \selfbraid{x}{\pi}{\pi^{-1}} \soplus  \selfbraid{y}{\pi}{\pi^{-1}} \soplus \braid{x}{y}{\pi}{\pi^{-1}} \soplus  \braid{y}{x}{\pi}{\pi^{-1}},
%\end{align}
%where,
%\begin{align}
%	\comm{x}{y}{\pi}{\pi^{-1}} \equiv \braid{x}{y}{\pi}{\pi^{-1}} \soplus \braid{y}{x}{\pi}{\pi^{-1}},
%\end{align}
%is the additive commutator of the $\xrightarrow{\pi}$ operator.

For known $x$ and unknown $y$ the object $y_\pi y$ acts as a one-time zero-knowledge proof of $y$. The proof is one-time as it is the same for all $x$.

\subsection{Hash function model}

Using the asymmetric model,
\begin{align}
	h: x\soplus \selfbraid{y}{\pi}{\pi^{-1}} \xrightarrow{\pi} \selfbraid{x}{\pi}{\pi^{-1}} \soplus y,
\end{align}
the $\braid{y}{y}{\pi}{\pi^{-1}}$ term acts a known pre-image modulation based on the hidden underlying action of unknown $\{y,\pi\}$, reproducing the property of hash pre-image salting. This provides a model for a deterministic pseudo-random hash function with hidden evaluation, while remaining verifiable.

This model implies the hash function cannot be collision free even over the same input and output domains. While in principle a function can be bijective over matching input and output domains the hash function model cannot be.

There may be an inherent underlying connection here via complexity arguments. Uniquely encoding arbitrary bijective maps \mbox{$\{0,1\}^n\to \{0,1\}^n$} has $O(2^n)$ space and time complexity. With polynomial time/space encoding this is unachievable if the function is modelled as random and unstructured.

* Collision space vanishes with $n\to\infty$, hence hash function model becomes bijective in the infinite limit. 

\subsection{TCF model}

Using the asymmetric model,
\begin{align}
	f: x\soplus \selfbraid{x_0 x_1}{\pi}{\pi^{-1}} \xrightarrow{\pi} \selfbraid{x}{\pi}{\pi^{-1}} \soplus \braid{x_0}{x_1}{\pi}{\pi^{-1}}.
\end{align}

\begin{align}
	f(x_0) &= x_0^\pi x_0^{\pi^{-1}} \cdot x_0^\pi x_1^{\pi^{-1}} = x_0^{\pi^{-1}} x_1^{\pi^{-1}},\nonumber\\
	f(x_1) &= x_1^\pi x_1^{\pi^{-1}} \cdot x_0^\pi x_1^{\pi^{-1}} = x_0^{\pi} x_1^{\pi}.
\end{align}

\begin{align}
	f(x) &= x^\pi x \cdot x_0 x_1,\nonumber\\
	f(x_0) &= x_0^\pi x_0^{\pi^{-1}} \cdot x_0^\pi x_1^{\pi^{-1}} = x_0^{\pi^{-1}} x_1^{\pi^{-1}},\nonumber\\
	f(x_1) &= x_1^\pi x_1^{\pi^{-1}} \cdot x_0^\pi x_1^{\pi^{-1}} = x_0^{\pi} x_1^{\pi}.
\end{align}

\section{Encrytpion}

Given secrets $\{x,m\}$ with respective public objects $\{\selfbraid{x}{\pi^{-1}}{\pi},\selfbraid{m}{{\pi}^{-1}}{\pi}\}$, public information can be expressed,
\begin{align}
	\selfbraid{x}{\pi^{-1}}{\pi} \cdot \selfbraid{m}{{\pi}^{-1}}{\pi} &= \selfbraid{m\cdot x}{{\pi}^{-1}}{\pi} \nonumber\\
	&= x_{\pi}x_{\pi^{-1}} \cdot m_\pi m_{\pi^{-1}}.
\end{align}
Now the solution revealing $m_\pi$ is,
\begin{align}
	\mathtt{sol} = x_\pi x_{\pi^{-1}} m_{\pi^{-1}},
\end{align}
hence unlocking $m$ under known $\pi$.


Applying known $\pi$ yields public,
\begin{align}
	x_{\pi^2}x \cdot m_{\pi^2} m.
\end{align}
Provision of,
\begin{align}
	\mathtt{sig} = m_{\pi^2} \cdot x_{\pi^2} \cdot x,
\end{align}
affords,
\begin{align}
	\mathtt{sig} \soplus \pi \circ \selfbraid{x\soplus m}{\pi^{-1}}{\pi} = m.
\end{align}

$\braid{x}{y}{\pi}{\pi^{-1}}$

%From the object,
%\begin{align}
%	x_\pi \soplus y,
%\end{align}
%* $y$ is released if $x$ and $\pi$ are known.\\
%* $x_\pi$ is released if $y$ is known.\\
%* $x$ is released if $\pi$ and $y$ are known.

An asymmetric trapdoor function on the differential $x\soplus y$ defined as,
\begin{align}
	[x,x\soplus y] \xrightarrow{\pi} [x, x \soplus y_\pi].
\end{align}
For known $\pi$, knowing $x$

$\pi$-symmeterised objects are pre-image resistant and public-safe, while their pre-images are not.

Via composition, differential codes for $\pi$-symmeterised objects preserve differentiality of their pre-image codes,
\begin{align}
	\diff{x}{y} \Rightarrow \diff{x_\pi x}{y_\pi y}.
\end{align}

Defining a secret key $s$ and public key $s\soplus p$ differentially we obtain,
\begin{align}
	\diff{s}{p} &= [s, s\soplus p],\nonumber\\
	[s, s\soplus p] &= [p\soplus s, p],\nonumber\\
	\diff{s_\pi s}{p_\pi p} &= [s\soplus p, s_\pi\soplus p_\pi],\nonumber\\
\end{align}

Similarly defining a message $m$ differentially encoded against the same secret key $s$ we have,
\begin{align}
	\diff{s}{m} = [s,s\soplus m].
\end{align}

Under composition this implies,
\begin{align}
	[s,s\soplus p] \soplus [s,s\soplus m] = [\mathbf{0},p\soplus m].	
\end{align}

Hence treating differential terms as shared information affords evaluation of $p\soplus m$ independent of $s$.

Introduce the term asymmetric term $m_\pi h(m)$ encoding a permuted message against its hash.

%$m_\pi h(m) \soplus $

Let us introduce symmetrised public terms,
\begin{align}
	s_\pi s, \nonumber\\
	p_\pi p.	
\end{align}

Using the permuted differential codes we have the identity,
\begin{align}
	[s,s \soplus p] \soplus [s, s_\pi \soplus m_\pi] = [\mathbf{0}, s_\pi s \soplus m_\pi p].
\end{align}

\begin{align}
	[s,s \soplus p] \soplus [p,p_\pi \soplus m_\pi] = [\mathtt{pk}, p_\pi s \soplus m_\pi p].
\end{align}

If the differential term is publicly shared this affords decoding under,
%\begin{align}
%	(m_\pi p) \soplus (m) = m
%\end{align}

\section{Old}

We define asymmetric key-pairs via their differential encoding,
\begin{align}
	\mathtt{sk}, \mathtt{pk} &\in \{0,1\}^n,
\end{align}

\begin{align}
	\kp &= \diff{\sk}{\pk} \nonumber\\
	&= [\sk,\sk \soplus \pk],
\end{align}

\section{Digital signatures}

Generate signature,
\begin{align}
	\sig(m,\sk) &= \diff{\sk}{\pk} \soplus \diff{\sk}{m} \nonumber\\
	&= \diff{\mathbf{0}}{\pk\soplus m} \nonumber\\
	&= \pk \soplus m.
\end{align}

Verify signature,
\begin{align}
	\ver(\sig,\pk) &= \Delta(m,\pk) \soplus \Delta() \nonumber\\
	&= \pk.
\end{align}

\section{Asymmetric encryption}

Encode,
\begin{align}
	\tilde{m} &= \enc(m,\pk) \nonumber\\
	&= \diff{m}{\sk} \nonumber\\
	&= \sk \soplus m.
\end{align}

Decode,
\begin{align}
	\dec(\tilde{m},\sk) &= \tilde{m} \soplus \bar\kp \nonumber\\
	&= \enc(\sk,m) \soplus \diff{\pk}{\sk} \nonumber\\
	&= \sk \soplus m.
\end{align}

\section{Authentication}

* $auth = (s1+p1)+(s2+p2) = p1+p2$

\section{Key reuse}

Consider multiple messages $m_i$ signed by the same public key,
\begin{align}
	\enc(m_i,\pk) &= \pk \soplus m_i, \nonumber\\
\end{align}

Verify signature,
\begin{align}
	\ver(\sig,\pk) &= \Delta(m,\pk) \soplus \Delta() \nonumber\\
	&= \pk.
\end{align}

\subsection{Key-establishment \& secret sharing}

\section{Old stuff}

\section{Differential hash codes}

A pair of bit-strings $\{x,y\}$ may be expressed differentially using the tuple,
\begin{align}
	[x,x\soplus y]_\soplus,
\end{align}
where the differential term $x\soplus y$ alone reveals no information about $x$ or $y$ while the non-differential term unlocks the code to reveal both. The validity of differentially encoded tuples may be trivially confirmed given knowledge of both terms.

We define the differential hash operators,
\begin{align}
	\Delta(x) &= h(x)\soplus x,\nonumber\\
	\Delta_\pi(x) &= h(x_\pi)\soplus x,
\end{align}
where $\pi\in S_n$ for $x\in\{0,1\}^n$ is a permutation over the elements of $x$. These encode a hash's image and pre-image together while revealing neither assuming hash pre-image resistance. We have the properties,
\begin{align}
	h(x) &= \Delta(x) \soplus x,\nonumber\\
	x &= \Delta(x) \soplus h(x).
\end{align}
The $\Delta$ operator inherits pre-image resistance from $h(\cdot)$. Knowing $\Delta(x)$ alone reveals neither $x$ nor $h(x)$, however additionally knowing $x$ or $h(x)$ enables verification of $\Delta(x)$. Finding $x$ for given $\Delta(x)$ reduces to the pre-image resistance of the hash function $h(\cdot)$.

The non-differentially encoded tuple $\{x,h(x)\}$ allows $x$ to unlock $h(x)$, while $h(x)$ cannot unlock $x$. The second element reveals $h(x)$ alone, but not $x$ via pre-image resistance. Under the differential encoding,
\begin{align}
	[x,\Delta(x)]_\soplus =[x,h(x)\soplus x]_\soplus,
\end{align}
the second element reveals neither $x$ nor $h(x)$, while the first element reveals both, given that $h(x)$ can be efficiently forward-evaluated. Alternately, under the differential encoding,
\begin{align}
	[h(x),\Delta(x)] = [h(x),h(x)\soplus x],
\end{align}
the non-differential term $h(x)$ affords unlocking the code but does not on its own reveal $x$ via hash pre-image resistance. Under both encodings knowing either $x$ or $h(x)$ alone enables verification.

The differential operator is distributive only over its unhashed components,
\begin{align}
	\Delta(x\soplus y) &= h(x\soplus y)\soplus x\soplus y \nonumber\\
	\Delta(x)\soplus\Delta(y) &= h(x)\soplus h(y)\soplus x\soplus y.
\end{align}
%Thus knowing $h(x\soplus y)$ does not unlock the object, whereas knowing both $x$ and $y$ does.

%Tuples of the form,
%\begin{align}
%	D(x,h(x)) &= [x, \Delta(x)], \nonumber\\
%	D(h(x),x) &= [h(x), \Delta(x)],
%\end{align}
%provide alternate differential encodings for $\{x,h(x)\}$, both affording efficient verification. A convenience is to collect terms known to different parties over the two sides of the encoding. Under both encodings knowing either $x$ or $h(x)$ unlocks both.

% We will generally treat the differential term as public and the non-differential term as private information.

%Taking bit-permuted tuples of this form, hash verification only succeeds if the correct inverse permutation is first applied.

%\subsection{Algebraic properties}

The symmetric difference between $\Delta(x\soplus y)$ and $\Delta(x)\soplus\Delta(y)$ gives the `distributor' (equivalent of commutator for distributivity),
\begin{align}
	\Delta(x\soplus y)\soplus \Delta(x)\soplus \Delta(y) = h(x\soplus y) \soplus h(x)\soplus h(y),
\end{align}
defining the distributivity of $\Delta$ operator over the action of $\soplus$.

Standard differential codes are composable,
\begin{align}
	[x,x\soplus y)]_\soplus \soplus [x',x'\soplus y']_\soplus\nonumber\\
	\sim [x\soplus x', x\soplus y \soplus x' \soplus y']_\soplus.
\end{align}
For differential hash codes,
\begin{align}
	[x,\Delta(x)]_\soplus,\nonumber\\
	[y,\Delta(y)]_\soplus,
\end{align}
we have distinct composition rules,
\begin{align}
	[x\soplus y,\Delta(x\soplus y)]_H,\nonumber\\
	[x\soplus y,\Delta(x) \soplus \Delta(y))]_\soplus.
\end{align}
The $[\cdot,\cdot]_H$ composition is verifiable by hashing the left hand term. The $[\cdot,\cdot]_\soplus$ composition is not hash-verifiable but preserves all differential encoding constraints.

Permutations $\pi$ are distributive over $\soplus$ but not commutative,
\begin{align}
	\pi(x\soplus y) &= \pi(x) \soplus \pi(y),\nonumber\\
	\pi(x) \soplus y &\neq x \soplus \pi(y),
\end{align}
whereas $\soplus$ is commutative but not distributive (in general, depending on parity of number of terms under distribution),
\begin{align}
	x\soplus y &= y \soplus x.
\end{align}

\begin{itemize}
	\item $h(m\soplus s)$ will reveal the private $h(s)$ for chosen $m=\mathbf{0}$.
	\item $h(m\soplus s \soplus x)$ will reveal the private $h(x)$ for chosen $m=x$ if $x$ is public.
	\item $h(\pi(m\soplus s)) = h(m_\pi \soplus s_\pi)$ can only reveal $h(s_\pi)$ (not secret) for public $\pi$ and chosen $m$, but cannot reveal secret $h(s)$.
\end{itemize}

\section{Asymmetric codes}

We define key-pairs as,
\begin{align}
	\mathtt{sk} &\in \{0,1\}^n, \nonumber\\
	\mathtt{pk} &= \{\mathtt{pk}_\Delta,\mathtt{pk}_\pi\},\nonumber\\
	\mathtt{pk}_\Delta &= \Delta(\mathtt{sk}),\nonumber\\
	\mathtt{pk}_\pi &\in S_n,
\end{align}
where $\mathtt{sk}$ be a secret bit-string, $h(\{0,1\}^n)\to\{0,1\}^n$ an $n$-bit endomorphic hash function, and $\pi\in S_n$ a permutation on $n$ bits. Since $|S_n|=n!$ encoding $\pi$ requires $\lceil\log_2(n!)\rceil$ bits. For $n=256$ we have $\lceil\log_2(n!)\rceil = 1684$ bits.

%and,
%\begin{align}
%	\pi &= h(\Delta(\mathtt{sk})),
%\end{align}
%is a non-unlocking public identifier, where,
%\begin{align}
%	x_\pi \equiv x\soplus h(\pi).
%\end{align}
Since $\mathtt{pk} = \Delta(\mathtt{sk})$ is public both $\mathtt{sk}$ and $h(\mathtt{sk})$ must be private to prevent unlocking the public key, both acting as trapdoors for the differential encoding.


%The signature confirms consistency between private and public information while revealing only $h(\mathtt{sk}_pi)$ about the private key. To use Alice's private key as $s$ we inhibit the disclosure of $\mathtt{sk}$ by applying a publicly known pre-image manipulation prevents the signature from revealing the secret key, instead using,

\begin{align}
	[m_\pi \soplus s_\pi, \Delta_\pi(m_\pi\soplus s_\pi)],
\end{align}

\begin{align}
	\Delta_\pi(m_\pi\soplus s_\pi) &= \Delta_\pi(m_\pi) \Delta_\pi(s_\pi) \nonumber\\
	&\soplus h(m_\pi) \soplus h(s_\pi) \soplus h(m_\pi \soplus s_\pi)
\end{align}

%Hence for,
%\begin{align}
%	[\mathtt{sig}, \Delta_\pi(m_\pi) \soplus \Delta(s_\pi)],
%\end{align}
%we require,
%\begin{align}
%	h(\mathtt{sig}) = \Delta_\pi(m_\pi) \soplus \Delta(s_\pi) \soplus h(m_\pi) \soplus h(s_\pi).
%\end{align}


%--
%We will employ the two alternate differential encodings as asymmetric primitives,
%\begin{align}
%	&[m\soplus s, \Delta(h(m)\soplus s)],\nonumber\\
%	&[h(m)\soplus s, \Delta(m\soplus s)],
%\end{align}
%with the identities,
%\begin{align}
%	\Delta(m\soplus s) &= \Delta(m)\soplus \Delta(s) \soplus h(m\soplus s) \soplus h(m)\soplus h(s),\nonumber\\
%	\Delta(h(m)\soplus s) &= \Delta(m)\soplus \Delta(s) \soplus h(h(m)\soplus s) \soplus m\soplus h(s).
%\end{align}
%
%\begin{align} 
%	\Delta(m)\soplus \Delta(s) &= \Delta(m\soplus s) \soplus h(m\soplus s) \soplus h(s) \soplus h(m),\nonumber\\
%\end{align}
%
%\begin{align} 
%	\Delta(m)\soplus \Delta(s) &= \Delta(m\soplus s) \soplus h(m\soplus s) \soplus h(s) \soplus h(m),\nonumber\\
%\end{align}
%
%---
%
%
%\begin{align}
%	\Delta(m_\pi \soplus s) &= h(m_\pi \soplus s) \soplus m_\pi \soplus s,\nonumber\\
%	\Delta(m_\pi) \soplus \Delta(s) &= h(m_\pi) \soplus h(s) \soplus m_\pi \soplus s,
%\end{align}
%
%Assume the message is known,
%\begin{align}
%	\Delta(m_\pi \soplus s_\pi) &= h(m_\pi \soplus s_\pi) \soplus m_\pi \soplus s_\pi \nonumber\\
%	&= \Delta(m_\pi) \soplus \Delta(s) \soplus h(m_\pi \soplus s) \soplus m_\pi \soplus s_\pi.
%\end{align}
%
%\begin{align}
%	\Delta(m_\pi \soplus s_\pi) = \Delta(m_\pi) \soplus \Delta(s) \soplus h(m_\pi \soplus s) \soplus m_\pi \soplus s.
%\end{align}
%
%%\begin{align}
%%	\Delta(s_\pi) &= h(s_\pi) \soplus s_\pi, \nonumber\\
%%	\Delta(s) &= \Delta(s_\pi) \soplus h(s_\pi) \soplus s_\pi.
%%\end{align}
%
%
%Hence (2): given $\Delta(m_\pi)$ Alice can extract the message via,
%\begin{align}
%		m = \Delta(\pi \soplus m) \soplus \Delta(s) \soplus h(\pi \soplus m) \soplus \pi,
%\end{align}
%
%--
%
%\begin{align}
%	&[h(m_\pi \soplus s_\pi), \Delta(m_\pi \soplus s_\pi)],\nonumber\\
%	&[h(m_\pi \soplus s_\pi), \Delta(m_\pi ) \soplus \Delta(s_\pi) \soplus h(m_\pi) \soplus h(s_\pi) \soplus h(m_\pi  \soplus s_\pi))],\nonumber\\
%\end{align}
%
%\begin{align}
%	h(m_\pi \soplus s_\pi) &= \Delta(m_\pi) \soplus \Delta(s_\pi) \nonumber\\
%	&\soplus h(m_\pi) \soplus h(s_\pi) \soplus h(m_\pi \soplus s_\pi),\nonumber\\
%\end{align}

\section{Digital signatures}

To sign message \mbox{$m\in\{0,1\}^n$} Alice makes public the differentially encoded, signed message $\Delta(m_\pi)$ and signature,
\begin{align}
	 \mathtt{sig}_\pi(m) = h(m_\pi \soplus \mathtt{sk}_\pi).
\end{align}
The signature has the property that when combined with public information it reveals the hash of the message being signed,
\begin{align}
	 \mathtt{sig}_\pi(m) \soplus \Delta(m) \soplus \Delta(\mathtt{sk}_\pi) = h(m).
\end{align}
Employing the modulated public key $\Delta(\mathtt{sk}_\pi)$,
\begin{align}
	\mathtt{sk}_\pi \equiv \mathtt{sk} \soplus h(\mathtt{pk}),
\end{align}
prevents the signature from revealing the trapdoor $h(\mathtt{sk})$ which unlocks the public key,
\begin{align}
	h(\mathtt{sk}) \soplus \Delta(\mathtt{sk}) &= \mathtt{sk},\nonumber\\
	h(\mathtt{sk}_\pi) \soplus \Delta(\mathtt{sk}) &\neq \mathtt{sk}.
\end{align}

%To verify Alice's signature Bob evaluates,
%\begin{align}
%	\mathtt{sig}_\pi(m) \soplus \Delta(s_\pi) \soplus \Delta(m) = m,
%\end{align}
%revealing $m$, which can be compared against its hash to verify the signature's validity.

%Taking Eq.~\eqref{eq:diff_sol} and grouping public information on the right we obtain,
%\begin{align}
%	h(m\soplus s) &= \Delta(m)\soplus \Delta(s),\nonumber\\
%	\mathtt{sig} &= h(m\soplus s).
%\end{align}

\section{Encryption}

For asymmetric encryption we reverse the roles of $m$ and $h(m)$. Bob wishes to send message $m$ to Alice and makes public,
\begin{align}
	\mathtt{enc}(m) &= \{\Delta(m), h(m)\}. 
\end{align}
Alice now decrypts using the message hash $h(m)$ to reveal the original message,
\begin{align}
	\Delta(s_\pi) \soplus \Delta(m) \soplus h(m) = m.
\end{align}

\subsection{Multi-sigs}

Signatures are commutative, additive and composable.
\begin{align}
	\mathtt{sig}_\pi(m) = \Delta(s_\pi) \soplus h(m),
\end{align}

\subsection{Key-establishment \& secret sharing}

Using the asymmetric encryption protocol, Alice finally communicates the verification hash,
\begin{align}
	\mathtt{key} = h(\mathtt{sk}\soplus m),
\end{align}
back to Bob, who also able to verify its validity. The verification hash now provides confirmation of a jointly prepared hash-based random number given by  the XOR-salted hash of Alice's secret key and Bob's chosen salt, which cannot be spoofed by either.

\section{Notes}

* The hash collision space translates to decoding failure.

Differentially encoded tuples are composable under bitwise XOR,
\begin{align}
	[x,\Delta(x)] \soplus [y,\Delta(y)] = [x\soplus y, \Delta(x)\soplus \Delta(y)],
\end{align}
via the commutativity of $\soplus$.

Compare above rhs,
\begin{align}
	h(x\soplus y) \soplus x \soplus y = h(x \soplus y) \soplus h(x) \soplus h(y).
\end{align}

$\pi$ known by inverting $\pi$ and multiplying the tuple elements to confirm consistency. For unknown or incorrect $\pi$ hash verification fails.

The bit permutation operator, $\pi(\cdot)$, is distribute over the bit-wise XOR operator, $\soplus$,
\begin{align}
	\pi(x)\soplus \pi(y) = \pi(x\soplus y).
\end{align}
Hence differential encoding relationships are preserved under the uniform action of $\pi$,
\begin{align}
	[x,x\soplus y] &\sim [\pi(x), \pi(x\soplus y)],
\end{align}
but are in general not preserved under non-uniform action of $\pi$,
\begin{align}
	[x,x\soplus y] \not\sim [\pi(x), x\soplus y].
\end{align}
We'll employ the shorthand,
\begin{align}
	\pi\circ[x,y] = [\pi(x),\pi(y)].,
\end{align}
to denote the uniform action of $\pi$ over a differential code.

While permutations are distributive over $\soplus$ they do not commute through hashes,
\begin{align}
	\pi(h(x)) \neq h(\pi(x)).	
\end{align}

\begin{align}
	\Delta(\pi(x\soplus y)) = h(\pi(x\soplus y)) \soplus \pi(x) \soplus \pi(y).
\end{align}

\subsection{Symmetric encryption}

Consider a single shared secret random bit-string differentially encoded against unique, single-use random bit-strings, also secret,
\begin{align}
	s &\in \{0,1\}^n,,\nonumber\\
	\mathcal{X}_i &\in \{0,1\}^n,\nonumber\\
	&[s,s\soplus \mathcal{X}_i].
\end{align}

Two parties $\{i,j\}$ publicly share their differential terms yielding the respective private and public terms,
\begin{align}
	\mathtt{Priv}:\, &\{s,\mathcal{X}_i,\mathcal{X}_j\},\nonumber\\
	\mathtt{Pub}:\, &\{s\soplus \mathcal{X}_i, s\soplus \mathcal{X}_j, \mathcal{X}_i\soplus\mathcal{X}_j \},
\end{align}
where,
\begin{align}
	\mathcal{X}_{i,j} = \mathcal{X}_i\soplus\mathcal{X}_j,
\end{align}
is a jointly established publicly-known random variable obtained under addition of both parties' communicated differential terms.

If $i$ wishes to send a message to $j$ they prepare,
\begin{align}
	[s, s\soplus m \soplus \mathcal{X}_i],
\end{align}
which can be differentially decoded from $s$ given $\mathcal{X}_i$.

Publicly communicating the differential term, the publicly and privately known objects are, 
\begin{align}
	\mathtt{Priv}:\, &\{s,m,\mathcal{X}_i,\mathcal{X}_j\},\nonumber\\
	\mathtt{Pub}:\, &\{s\soplus \mathcal{X}_i, s\soplus \mathcal{X}_j, \mathcal{X}_{i,j},\nonumber\\
	 &s\soplus m\soplus \mathcal{X}_i, s\soplus m\soplus \mathcal{X}_j,\nonumber\\
	 &m\soplus \mathcal{X}_j, m\soplus\mathcal{X}_i \}.
\end{align}
Now public information is unable to reveal $m$ or $s$ while the additional private information can.

The spaces of private and public information form groups with group generators given by privately held and publicly shared objects,
\begin{align}
	G_\mathrm{priv} &\sim \mathrm{GF}(11) \sim \langle s,m,\mathcal{X}_i,\mathcal{X}_j \rangle, \nonumber\\
	G_\mathrm{pub} &\sim \mathrm{GF}(7) \sim \langle s\soplus \mathcal{X}_i, s\soplus \mathcal{X}_j, m\soplus\mathcal{X}_i \rangle.
\end{align}

Upon publicly communicating only the differential terms other parties in possession of $s$ can decode all $x_i$. Upon repeating using independent samples of $x_i$ but with the same secret Eve is in possession of $s\soplus x_i$ for each sample. Combining multiple interceptions Eve can produce,
\begin{align}
	s\soplus x_i \soplus s \soplus x_j &= x_i \soplus x_j,
\end{align}
which is independent of $s$ and reveals no information about $s$ in the absence of knowing any $x_i$. Thus over $n$ iterations the parties securely share $\{x\}$ where all $x_i$ are statistically independent, maximum entropy random variables. Concatenation enables a finite length shared secret to facilitate the secure sharing of arbitrarily long random bit-strings which can subsequently be employed in a one-time pad cipher, affording statistical security bounded by the entropy rate.

The security of $s\soplus x$ can be information-theoretically interpreted in terms of the mutual information between the secret $s$ and public information in $s\soplus x$. For random variables $X$ and $Y$ their mutual information is given by,
\begin{align}
	I(X;Y) = H(X) + H(Y) - H(X,Y).	
\end{align}
Let,
\begin{align}
 	&X\equiv \{s,x\},\nonumber\\
 	&Y\equiv s\soplus x,
\end{align} 
where $X$ denotes private information and $Y$ public information. We have the identities,
\begin{align}
 	H(X) &\leq H(Y) \leq 1,\nonumber\\
	H(X,Y) &= 2H(X),\nonumber\\
	I(X;Y) &= 2H(X)-H(X,Y)\nonumber\\
	&= 0,\nonumber\\
	I(E) &= I(X_s;Y) = I(X_x;Y)\nonumber\\
	&= H(X)+H(Y)-H(X,Y)\nonumber\\
	&= H(Y) - H(X)\nonumber\\
	&\leq 1-H(X).
\end{align}
Hence the mutual information between either private random variables and the encoded public random variable, equivalently the extractable information by an eavesdropper, is upper bounded by $1-H(X)$ where $0\leq H(X)\leq 1$. For perfect entropy sources where $H(X)=1$ this implies zero information leakage to Eve.

\subsubsection{Quantum key distribution}

QKD can be equivalently conceptualised. Consider the entanglement-based E91 QKD protocol where for each Bell pair Alice and Bob choose random measurement bases with random measurement outcomes,
\begin{align}
	b_{A,B} &\in \{Z\equiv 0, X\equiv 1\},\nonumber\\
	m_{A,B} &\in \{0,1\}.
\end{align}
Post-selecting on outcomes where the measurement bases chosen by Alice and Bob are consistent, their respective measurement outcomes are dictated by parity constraints,
\begin{align}
	m_A\soplus m_B = p_b,\quad (b_A=b_B,\, p_b\in\{0,1\}).
\end{align}
where $p_b$ is imposed by the choice of Bell pair and measurement basis. Under this model for QKD security is statistical and associated with the entropy of $b$ and $m$, mediated by entanglement enforcing their parity constraints.

\section{Differential hash codes}

A pair of bit-strings $\{x,y\}$ may be expressed differentially using the tuple,
\begin{align}
	[x,x\soplus y]_\soplus,
\end{align}
where the differential term $x\soplus y$ alone reveals no information about $x$ or $y$ while the non-differential term unlocks the code to reveal both. The validity of differentially encoded tuples may be trivially confirmed given knowledge of both terms.

We define the differential hash operators,
\begin{align}
	\Delta(x) &= h(x)\soplus x,\nonumber\\
	\Delta_\pi(x) &= h(x_\pi)\soplus x,
\end{align}
where $\pi\in S_n$ for $x\in\{0,1\}^n$ is a permutation over the elements of $x$. These encode a hash's image and pre-image together while revealing neither assuming hash pre-image resistance. We have the properties,
\begin{align}
	h(x) &= \Delta(x) \soplus x,\nonumber\\
	x &= \Delta(x) \soplus h(x).
\end{align}
The $\Delta$ operator inherits pre-image resistance from $h(\cdot)$. Knowing $\Delta(x)$ alone reveals neither $x$ nor $h(x)$, however additionally knowing $x$ or $h(x)$ enables verification of $\Delta(x)$. Finding $x$ for given $\Delta(x)$ reduces to the pre-image resistance of the hash function $h(\cdot)$.

The non-differentially encoded tuple $\{x,h(x)\}$ allows $x$ to unlock $h(x)$, while $h(x)$ cannot unlock $x$. The second element reveals $h(x)$ alone, but not $x$ via pre-image resistance. Under the differential encoding,
\begin{align}
	[x,\Delta(x)]_\soplus =[x,h(x)\soplus x]_\soplus,
\end{align}
the second element reveals neither $x$ nor $h(x)$, while the first element reveals both, given that $h(x)$ can be efficiently forward-evaluated. Alternately, under the differential encoding,
\begin{align}
	[h(x),\Delta(x)] = [h(x),h(x)\soplus x],
\end{align}
the non-differential term $h(x)$ affords unlocking the code but does not on its own reveal $x$ via hash pre-image resistance. Under both encodings knowing either $x$ or $h(x)$ alone enables verification.

The differential operator is distributive only over its unhashed components,
\begin{align}
	\Delta(x\soplus y) &= h(x\soplus y)\soplus x\soplus y \nonumber\\
	\Delta(x)\soplus\Delta(y) &= h(x)\soplus h(y)\soplus x\soplus y.
\end{align}
%Thus knowing $h(x\soplus y)$ does not unlock the object, whereas knowing both $x$ and $y$ does.

%Tuples of the form,
%\begin{align}
%	D(x,h(x)) &= [x, \Delta(x)], \nonumber\\
%	D(h(x),x) &= [h(x), \Delta(x)],
%\end{align}
%provide alternate differential encodings for $\{x,h(x)\}$, both affording efficient verification. A convenience is to collect terms known to different parties over the two sides of the encoding. Under both encodings knowing either $x$ or $h(x)$ unlocks both.

% We will generally treat the differential term as public and the non-differential term as private information.

%Taking bit-permuted tuples of this form, hash verification only succeeds if the correct inverse permutation is first applied.

%\subsection{Algebraic properties}

The symmetric difference between $\Delta(x\soplus y)$ and $\Delta(x)\soplus\Delta(y)$ gives the `distributor' (equivalent of commutator for distributivity),
\begin{align}
	\Delta(x\soplus y)\soplus \Delta(x)\soplus \Delta(y) = h(x\soplus y) \soplus h(x)\soplus h(y),
\end{align}
defining the distributivity of $\Delta$ operator over the action of $\soplus$.

Standard differential codes are composable,
\begin{align}
	[x,x\soplus y)]_\soplus \soplus [x',x'\soplus y']_\soplus\nonumber\\
	\sim [x\soplus x', x\soplus y \soplus x' \soplus y']_\soplus.
\end{align}
For differential hash codes,
\begin{align}
	[x,\Delta(x)]_\soplus,\nonumber\\
	[y,\Delta(y)]_\soplus,
\end{align}
we have distinct composition rules,
\begin{align}
	[x\soplus y,\Delta(x\soplus y)]_H,\nonumber\\
	[x\soplus y,\Delta(x) \soplus \Delta(y))]_\soplus.
\end{align}
The $[\cdot,\cdot]_H$ composition is verifiable by hashing the left hand term. The $[\cdot,\cdot]_\soplus$ composition is not hash-verifiable but preserves all differential encoding constraints.

Permutations $\pi$ are distributive over $\soplus$ but not commutative,
\begin{align}
	\pi(x\soplus y) &= \pi(x) \soplus \pi(y),\nonumber\\
	\pi(x) \soplus y &\neq x \soplus \pi(y),
\end{align}
whereas $\soplus$ is commutative but not distributive (in general, depending on parity of number of terms under distribution),
\begin{align}
	x\soplus y &= y \soplus x.
\end{align}

\begin{itemize}
	\item $h(m\soplus s)$ will reveal the private $h(s)$ for chosen $m=\mathbf{0}$.
	\item $h(m\soplus s \soplus x)$ will reveal the private $h(x)$ for chosen $m=x$ if $x$ is public.
	\item $h(\pi(m\soplus s)) = h(m_\pi \soplus s_\pi)$ can only reveal $h(s_\pi)$ (not secret) for public $\pi$ and chosen $m$, but cannot reveal secret $h(s)$.
\end{itemize}

\section{Asymmetric codes}

We define key-pairs as,
\begin{align}
	\mathtt{sk} &\in \{0,1\}^n, \nonumber\\
	\mathtt{pk} &= \{\mathtt{pk}_\Delta,\mathtt{pk}_\pi\},\nonumber\\
	\mathtt{pk}_\Delta &= \Delta(\mathtt{sk}),\nonumber\\
	\mathtt{pk}_\pi &\in S_n,
\end{align}
where $\mathtt{sk}$ be a secret bit-string, $h(\{0,1\}^n)\to\{0,1\}^n$ an $n$-bit endomorphic hash function, and $\pi\in S_n$ a permutation on $n$ bits. Since $|S_n|=n!$ encoding $\pi$ requires $\lceil\log_2(n!)\rceil$ bits. For $n=256$ we have $\lceil\log_2(n!)\rceil = 1684$ bits.

%and,
%\begin{align}
%	\pi &= h(\Delta(\mathtt{sk})),
%\end{align}
%is a non-unlocking public identifier, where,
%\begin{align}
%	x_\pi \equiv x\soplus h(\pi).
%\end{align}
Since $\mathtt{pk} = \Delta(\mathtt{sk})$ is public both $\mathtt{sk}$ and $h(\mathtt{sk})$ must be private to prevent unlocking the public key, both acting as trapdoors for the differential encoding.


%The signature confirms consistency between private and public information while revealing only $h(\mathtt{sk}_pi)$ about the private key. To use Alice's private key as $s$ we inhibit the disclosure of $\mathtt{sk}$ by applying a publicly known pre-image manipulation prevents the signature from revealing the secret key, instead using,

\begin{align}
	[m_\pi \soplus s_\pi, \Delta_\pi(m_\pi\soplus s_\pi)],
\end{align}

\begin{align}
	\Delta_\pi(m_\pi\soplus s_\pi) &= \Delta_\pi(m_\pi) \Delta_\pi(s_\pi) \nonumber\\
	&\soplus h(m_\pi) \soplus h(s_\pi) \soplus h(m_\pi \soplus s_\pi)
\end{align}

%Hence for,
%\begin{align}
%	[\mathtt{sig}, \Delta_\pi(m_\pi) \soplus \Delta(s_\pi)],
%\end{align}
%we require,
%\begin{align}
%	h(\mathtt{sig}) = \Delta_\pi(m_\pi) \soplus \Delta(s_\pi) \soplus h(m_\pi) \soplus h(s_\pi).
%\end{align}


%--
%We will employ the two alternate differential encodings as asymmetric primitives,
%\begin{align}
%	&[m\soplus s, \Delta(h(m)\soplus s)],\nonumber\\
%	&[h(m)\soplus s, \Delta(m\soplus s)],
%\end{align}
%with the identities,
%\begin{align}
%	\Delta(m\soplus s) &= \Delta(m)\soplus \Delta(s) \soplus h(m\soplus s) \soplus h(m)\soplus h(s),\nonumber\\
%	\Delta(h(m)\soplus s) &= \Delta(m)\soplus \Delta(s) \soplus h(h(m)\soplus s) \soplus m\soplus h(s).
%\end{align}
%
%\begin{align} 
%	\Delta(m)\soplus \Delta(s) &= \Delta(m\soplus s) \soplus h(m\soplus s) \soplus h(s) \soplus h(m),\nonumber\\
%\end{align}
%
%\begin{align} 
%	\Delta(m)\soplus \Delta(s) &= \Delta(m\soplus s) \soplus h(m\soplus s) \soplus h(s) \soplus h(m),\nonumber\\
%\end{align}
%
%---
%
%
%\begin{align}
%	\Delta(m_\pi \soplus s) &= h(m_\pi \soplus s) \soplus m_\pi \soplus s,\nonumber\\
%	\Delta(m_\pi) \soplus \Delta(s) &= h(m_\pi) \soplus h(s) \soplus m_\pi \soplus s,
%\end{align}
%
%Assume the message is known,
%\begin{align}
%	\Delta(m_\pi \soplus s_\pi) &= h(m_\pi \soplus s_\pi) \soplus m_\pi \soplus s_\pi \nonumber\\
%	&= \Delta(m_\pi) \soplus \Delta(s) \soplus h(m_\pi \soplus s) \soplus m_\pi \soplus s_\pi.
%\end{align}
%
%\begin{align}
%	\Delta(m_\pi \soplus s_\pi) = \Delta(m_\pi) \soplus \Delta(s) \soplus h(m_\pi \soplus s) \soplus m_\pi \soplus s.
%\end{align}
%
%%\begin{align}
%%	\Delta(s_\pi) &= h(s_\pi) \soplus s_\pi, \nonumber\\
%%	\Delta(s) &= \Delta(s_\pi) \soplus h(s_\pi) \soplus s_\pi.
%%\end{align}
%
%
%Hence (2): given $\Delta(m_\pi)$ Alice can extract the message via,
%\begin{align}
%		m = \Delta(\pi \soplus m) \soplus \Delta(s) \soplus h(\pi \soplus m) \soplus \pi,
%\end{align}
%
%--
%
%\begin{align}
%	&[h(m_\pi \soplus s_\pi), \Delta(m_\pi \soplus s_\pi)],\nonumber\\
%	&[h(m_\pi \soplus s_\pi), \Delta(m_\pi ) \soplus \Delta(s_\pi) \soplus h(m_\pi) \soplus h(s_\pi) \soplus h(m_\pi  \soplus s_\pi))],\nonumber\\
%\end{align}
%
%\begin{align}
%	h(m_\pi \soplus s_\pi) &= \Delta(m_\pi) \soplus \Delta(s_\pi) \nonumber\\
%	&\soplus h(m_\pi) \soplus h(s_\pi) \soplus h(m_\pi \soplus s_\pi),\nonumber\\
%\end{align}

\section{Digital signatures}

To sign message \mbox{$m\in\{0,1\}^n$} Alice makes public the differentially encoded, signed message $\Delta(m_\pi)$ and signature,
\begin{align}
	 \mathtt{sig}_\pi(m) = h(m_\pi \soplus \mathtt{sk}_\pi).
\end{align}
The signature has the property that when combined with public information it reveals the hash of the message being signed,
\begin{align}
	 \mathtt{sig}_\pi(m) \soplus \Delta(m) \soplus \Delta(\mathtt{sk}_\pi) = h(m).
\end{align}
Employing the modulated public key $\Delta(\mathtt{sk}_\pi)$,
\begin{align}
	\mathtt{sk}_\pi \equiv \mathtt{sk} \soplus h(\mathtt{pk}),
\end{align}
prevents the signature from revealing the trapdoor $h(\mathtt{sk})$ which unlocks the public key,
\begin{align}
	h(\mathtt{sk}) \soplus \Delta(\mathtt{sk}) &= \mathtt{sk},\nonumber\\
	h(\mathtt{sk}_\pi) \soplus \Delta(\mathtt{sk}) &\neq \mathtt{sk}.
\end{align}

%To verify Alice's signature Bob evaluates,
%\begin{align}
%	\mathtt{sig}_\pi(m) \soplus \Delta(s_\pi) \soplus \Delta(m) = m,
%\end{align}
%revealing $m$, which can be compared against its hash to verify the signature's validity.

%Taking Eq.~\eqref{eq:diff_sol} and grouping public information on the right we obtain,
%\begin{align}
%	h(m\soplus s) &= \Delta(m)\soplus \Delta(s),\nonumber\\
%	\mathtt{sig} &= h(m\soplus s).
%\end{align}

\section{Encryption}

For asymmetric encryption we reverse the roles of $m$ and $h(m)$. Bob wishes to send message $m$ to Alice and makes public,
\begin{align}
	\mathtt{enc}(m) &= \{\Delta(m), h(m)\}. 
\end{align}
Alice now decrypts using the message hash $h(m)$ to reveal the original message,
\begin{align}
	\Delta(s_\pi) \soplus \Delta(m) \soplus h(m) = m.
\end{align}

\subsection{Multi-sigs}

Signatures are commutative, additive and composable.
\begin{align}
	\mathtt{sig}_\pi(m) = \Delta(s_\pi) \soplus h(m),
\end{align}

\subsection{Key-establishment \& secret sharing}

Using the asymmetric encryption protocol, Alice finally communicates the verification hash,
\begin{align}
	\mathtt{key} = h(\mathtt{sk}\soplus m),
\end{align}
back to Bob, who also able to verify its validity. The verification hash now provides confirmation of a jointly prepared hash-based random number given by  the XOR-salted hash of Alice's secret key and Bob's chosen salt, which cannot be spoofed by either.

\section{Notes}

* The hash collision space translates to decoding failure.

Differentially encoded tuples are composable under bitwise XOR,
\begin{align}
	[x,\Delta(x)] \soplus [y,\Delta(y)] = [x\soplus y, \Delta(x)\soplus \Delta(y)],
\end{align}
via the commutativity of $\soplus$.

Compare above rhs,
\begin{align}
	h(x\soplus y) \soplus x \soplus y = h(x \soplus y) \soplus h(x) \soplus h(y).
\end{align}

$\pi$ known by inverting $\pi$ and multiplying the tuple elements to confirm consistency. For unknown or incorrect $\pi$ hash verification fails.

The bit permutation operator, $\pi(\cdot)$, is distribute over the bit-wise XOR operator, $\soplus$,
\begin{align}
	\pi(x)\soplus \pi(y) = \pi(x\soplus y).
\end{align}
Hence differential encoding relationships are preserved under the uniform action of $\pi$,
\begin{align}
	[x,x\soplus y] &\sim [\pi(x), \pi(x\soplus y)],
\end{align}
but are in general not preserved under non-uniform action of $\pi$,
\begin{align}
	[x,x\soplus y] \not\sim [\pi(x), x\soplus y].
\end{align}
We'll employ the shorthand,
\begin{align}
	\pi\circ[x,y] = [\pi(x),\pi(y)].,
\end{align}
to denote the uniform action of $\pi$ over a differential code.

While permutations are distributive over $\soplus$ they do not commute through hashes,
\begin{align}
	\pi(h(x)) \neq h(\pi(x)).	
\end{align}

\begin{align}
	\Delta(\pi(x\soplus y)) = h(\pi(x\soplus y)) \soplus \pi(x) \soplus \pi(y).
\end{align}

\section{From other document}

\subsubsection{Notes}

If $\Delta(x)=h(x)\soplus x$ is public information both $x$ and $h(x)$ must be private.

Decrypt $m$ with $h(m)$ requires the locking construction,
\begin{align}
	&[h(m), m\soplus h(m)]_\soplus	= [h(m), \Delta(m)]_\soplus,\nonumber\\
	&[s\soplus h(m), \Delta(s) \soplus \Delta(m)]_\soplus,\nonumber\\
	&[s\soplus h(m), \Delta(s\soplus h(m))]_\soplus \nonumber\\
	&[s\soplus h(m), \Delta(s) \soplus \Delta(m) \soplus h(s\soplus h(m)) \soplus h(m) \soplus h(s)]_\soplus,\nonumber\\
%	&[s\soplus h(m), \Delta(s) \soplus \Delta(m) \soplus  \soplus h(m) \soplus h(s)]_\soplus
\end{align}
if $\Delta(m)$ is public.


This does not unlock from known $\pi$,
\begin{align}
	[h(\pi(m)), \pi(m) \soplus h(m)]_\soplus
\end{align}

This unlocks,
\begin{align}
	[h(\pi(s \soplus m)), \Delta(s \soplus m)]_\soplus
\end{align}

%Equivalently,
%\begin{align}
%	&[h(s\soplus h(m)), \Delta(s\soplus h(m))]_\soplus \nonumber\\
%	&[s \soplus h(m), \Delta(s) \soplus \Delta(m)]_\soplus \nonumber\\
%	&[\pi(s) \soplus h(m), \Delta(s) \soplus \Delta(m)]_\soplus \to m \nonumber\\
%	&[\pi(s) \soplus \pi(h(m)), \Delta(s) \soplus \pi(\Delta(m))]_\soplus \to m \nonumber\\
%\end{align}
%unlocks for known $\Delta(\pi(s))$ (private).

Want to decrypt with,
\begin{align}
	h(\pi(s\soplus h(m)) &= \Delta(\pi(s\soplus h(m))) \nonumber\\
	&\soplus \pi(s) \soplus \pi(h(m)).
\end{align}

\begin{align}
	[h(m), \Delta(\pi(m))\soplus \Delta(\pi(s))]_\soplus
\end{align}
unlocks for known $\Delta(\pi(s))$ (private).

\begin{align}
	\Delta(\pi(m))\soplus \Delta(\pi(s))	= \Delta
\end{align}


\begin{align}
	&\mathtt{sig} = \Delta(m) = \pi(m) \soplus h(\pi(m)) \nonumber\\
	&\pi(m) = \mathtt{sig} \soplus h(\pi(m)) 
\end{align}

\subsection{Digital signatures}

Consider parties Alice and Bob where Alice wants to sign the message \mbox{$m\in \{0,1\}^n$}. Alice prepares the signature,
\begin{align}
	\mathtt{sig}(m) &= \{\pi(m), \Delta(m), h(\mathtt{sk} \soplus m)\}.
\end{align}

Bob prepares $\pi(\Delta(m))$ and knows $\pi(\Delta(\mathtt{sk}))$. We have the relationship,
\begin{align}
	\pi(\mathtt{sk} \soplus m) = \pi(\Delta(\mathtt{sk}) \soplus \Delta(m) \soplus h(m) \soplus(h(\mathtt{sk}))%  \soplus h(\mathtt{sk}) \soplus h(m)
\end{align}

The encodings,
\begin{align}
	[\mathtt{sk}, \Delta(\mathtt{sk})]_H, [h(\mathtt{sk}), \Delta(\mathtt{sk})]_\soplus \nonumber\\
	[m, \Delta(m)]_H, [h(m), \Delta(m)]_\soplus \nonumber\\
	[m \soplus \mathtt{sk} \soplus h(m) \soplus h(\mathtt{sk}), \Delta(m) \soplus \Delta(\mathtt{sk})]_\soplus
\end{align}
enable verification by hashing the first term.

The differential code,
\begin{align}
	[\mathtt{sk} \soplus m, \Delta(\mathtt{sk} \soplus m)] %\soplus h(m) \soplus h(\mathtt{sk})]
\end{align}
is verifiable given $h(\mathtt{sk} \soplus m)$, while the permuted code,
\begin{align}
	[\pi(\mathtt{sk} \soplus m), \Delta(\pi(\mathtt{sk} \soplus m))]_H 
\end{align}
is only verifiable with $h(\pi(\mathtt{sk} \soplus m))$.

\begin{align}
	&[h(\mathtt{sk} \soplus m), \Delta(\mathtt{sk} \soplus m)]_\soplus \nonumber\\
	&[h(\pi(\mathtt{sk} \soplus m)), \Delta(\pi(\mathtt{sk} \soplus m))]_\soplus
\end{align}
are both verifiable from direct multiplication.

%\begin{align}
%	&[h(\pi(\mathtt{sk} \soplus m)), \Delta(\mathtt{sk} \soplus m)]_\soplus \nonumber\\
%	&[h(\pi(\mathtt{sk} \soplus m)), h(\mathtt{sk} \soplus m)\soplus \mathtt{sk} \soplus m]_\soplus
%\end{align}
%is verifiable from direct multiplication where $\pi$ is known.



%\begin{align}
%	\pi(\Delta(\mathtt{sk} \soplus m)) &= \pi(h(\mathtt{sk} \soplus m)) \soplus \pi(\mathtt{sk}) \soplus \pi(\Delta(m)\soplus h(m)).
%\end{align}

\subsection{Blah}

Hence,
\begin{align}
	[h(\pi(\mathtt{sk} \soplus m)), \Delta(\pi(\mathtt{sk} \soplus m))]
\end{align}
affords direct verification by multiplying ($t_1\cdot t_2 = h(t_2)$). The second term is equivalent to,
\begin{align}
	t_2 &= \Delta(\pi(\mathtt{sk} \soplus m)) \nonumber\\
	&= \Delta(\pi(\mathtt{sk})) \soplus \Delta(\pi(m)) \nonumber\\
	&\soplus h(\pi(\mathtt{sk} \soplus m))
 \soplus h(\pi(\mathtt{sk})) \soplus h(\pi(m))
\end{align}

%\begin{align}
%	\pi(\Delta(\pi(x))) &= \pi(h(\pi(x))) \soplus x	
%\end{align}

Let signature be,
\begin{align}
	\mathtt{sig} &= h(\pi(\mathtt{sk} \soplus m)),\nonumber\\
\end{align}

\begin{align}
	\mathtt{ver} &= \Delta(\pi(\mathtt{sk} \soplus m)) \nonumber\\
\end{align}

\begin{align}
	[\mathtt{sig}, \mathtt{ver}]
\end{align}


\section{Blah}

\begin{align}
	\Delta(\pi(\mathtt{sk} \soplus m)) &= h(\pi(\mathtt{sk} \soplus m)) \soplus \pi(\mathtt{sk} \soplus m) \nonumber\\
	&= h(\pi(\mathtt{sk}) \soplus \pi(m)) \soplus \pi(\mathtt{sk} \soplus m). \nonumber\\
	\Delta(\pi(\mathtt{sk})) \soplus \Delta(\pi(m)) &= \pi(\mathtt{sk}) \soplus \pi(m) \nonumber\\
	&\soplus h(\pi(\mathtt{sk})) \soplus h(\pi(m)).\nonumber\\
	\Delta(\pi(\mathtt{sk} \soplus m)) &= \Delta(\pi(\mathtt{sk})) \soplus \Delta(\pi(m)) \nonumber\\
	&\soplus h(\pi(\mathtt{sk} \soplus m))
 \soplus h(\pi(\mathtt{sk})) \soplus h(\pi(m))
\end{align}

\begin{align}
	\Delta(x\soplus\pi(x)) &= h(x\soplus \pi(x)) \soplus x \soplus \pi(x).
\end{align}

\begin{align}
	\Delta(\mathtt{sk} \soplus m \soplus \pi(\mathtt{sk}\soplus m)) &= h(\mathtt{sk} \soplus m \soplus \pi(\mathtt{sk}) \soplus \pi(m)) \nonumber\\
	&\mathtt{sk} \soplus m \soplus \pi(\mathtt{sk}) \soplus \pi(m).
\end{align}

The differential permuted code,
\begin{align}
	&[\pi(\mathtt{sk} \soplus m), \Delta(\pi(\mathtt{sk} \soplus m))]
\end{align}
is verifiable from,
\begin{align}
	h(\pi(\mathtt{sk} \soplus m))
\end{align}

The differential permuted code,
\begin{align}
	&[\pi(\mathtt{sk} \soplus m), \Delta(\pi(\mathtt{sk} \soplus m))]
\end{align}
is verifiable from,
\begin{align}
	&h(\pi(\mathtt{sk} \soplus m)) \soplus \pi(\mathtt{sk} \soplus m) = bob \nonumber\\
	&\soplus h(\pi(\mathtt{sk} \soplus m)) \soplus h(\pi(\mathtt{sk})) \soplus h(\pi(m)) \nonumber\\
	&= 
\end{align} 

While,
\begin{align}
	&[\mathtt{sk} \soplus m, \Delta(\mathtt{sk} \soplus m)] \nonumber\\
	&= [\mathtt{sk} \soplus m, \Delta(\mathtt{sk}) \soplus \Delta(m) \nonumber\\
	&\soplus h(\mathtt{sk} \soplus m) \soplus h(\mathtt{sk}) \soplus h(m)],
\end{align}
is verifiable from $h(\mathtt{sk} \soplus m)$.

Bob's test passes if,
\begin{align}
	\pi(\mathtt{sk} \soplus m) &= \Delta(\pi(\mathtt{sk})) \soplus \Delta(\pi(m)) \soplus h(\pi(\mathtt{sk})) \soplus h(\pi(m))
\end{align}

Bob is not allowed to know $h(\mathtt{sk})$.

Similarly,
\begin{align}
	&[\mathtt{sk} \soplus m, \Delta(\mathtt{sk}\soplus m)] \nonumber\\
	&= [\mathtt{sk} \soplus m, h(\mathtt{sk}\soplus m) \soplus h(\mathtt{sk}) \soplus h(m)],
\end{align}
are verifiable from hashing the first term, while,
\begin{align}
	&[\pi(\mathtt{sk} \soplus m), \Delta(\mathtt{sk}\soplus m)] \nonumber\\
	&= [\pi(\mathtt{sk} \soplus m), h(\mathtt{sk}\soplus m) \soplus h(\mathtt{sk}) \soplus h(m)],
\end{align}
are verifiable by hashing the unpermuted first term. Equivalently,
\begin{align}
	&[\pi(\mathtt{sk} \soplus m), \Delta(\mathtt{sk}\soplus m)] \nonumber\\
	&[\pi(\mathtt{sk} \soplus m), \Delta(\mathtt{sk})\soplus \Delta(m) \soplus h(\mathtt{sk}\soplus m) \soplus h(\mathtt{sk}) \soplus h(m)] \nonumber\\\end{align}
is verifiable by hashing the unpermuted first term.

Using,
\begin{align}
	\Delta(\mathtt{sk}) \soplus \Delta(m) &= \Delta(\mathtt{sk} \soplus m) \soplus h(\mathtt{sk} \soplus m)	\soplus h(\mathtt{sk}) \soplus h(m),\nonumber\\
\end{align}

%We have,
%\begin{align}
%	\pi(\Delta(\mathtt{sk}\soplus m)) = \pi(\Delta(\mathtt{sk}) \soplus \Delta(m) h(\mathtt{sk}\soplus m) \soplus h(\mathtt{sk}) \soplus h(m))
%\end{align}

Ver:
\begin{align}
	\{\pi(m)\soplus \pi(\mathtt{sk}), \Delta(m)\soplus \Delta(\mathtt{sk})\} \nonumber\\
	\{\pi(m\soplus \mathtt{sk}), \Delta(m)\soplus \Delta(\mathtt{sk})\}
\end{align}

We have the relationships,
\begin{align}
	\Delta(\mathtt{sk}) \soplus \Delta(m) &= \mathtt{sk} \soplus m \soplus h(\texttt{sk}) \soplus h(m),\nonumber\\
	\Delta(\mathtt{sk} \soplus m)	 &= h(\mathtt{sk} \soplus m) \soplus \mathtt{sk} \soplus m,\nonumber\\
\end{align}
Under composition we obtain,
\begin{align}
	\Delta(\mathtt{sk} \soplus m)	 \soplus \Delta(\mathtt{sk}) \soplus \Delta(m) &= h(\mathtt{sk} \soplus m) \soplus h(\mathtt{sk}) \soplus h(m).	
\end{align}
The differential encoding,
\begin{align}
	[h(\mathtt{sk}\soplus m), \Delta(\mathtt{sk} \soplus m)],
\end{align}

Consider the permuted differential code,
\begin{align}
	[\pi(\mathtt{sk}\soplus m), \pi(\Delta(\mathtt{sk})) \soplus \pi(\Delta(m))].
\end{align}
we equivalently obtain,
\begin{align}
	[\Delta(\mathtt{sk} \soplus m) \soplus h(\mathtt{sk} \soplus m), \Delta(\mathtt{sk}) \soplus \Delta(m)].
\end{align}
%is verifiable if $\pi(\mathtt{sk} \soplus m)$ is known.

Therefore if Alice provides the signature,
\begin{align}
	\mathtt{sig}(m) = [\pi(\mathtt{sk} \soplus m), h(\mathtt{sk} \soplus m)],
\end{align}	
Bob is able to verify via,
\begin{align}
		[\mathtt{sig}(m),\Delta(\mathtt{sk}) \soplus \Delta(m)].
\end{align}


%where $\Delta(m)$ are $\Delta(\mathtt{sk})$ are known to Bob.

%which Bob is able to verify using Alice's verification hash,
%\begin{align}
%	h(\mathtt{sk}\soplus m).
%\end{align}
%
%For $n$-bit messages 

\bibliography{bibliography.bib}

\end{document}